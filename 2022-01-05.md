# MySQL
#mysql 

接上回[[2022-01-04#Mysql]]的B+树索引的适应条件。

全值匹配的时候适合。注意在组合索引的适合，查询条件的索引值顺序不影响结果，因为mysql的查询优化器会做优化，并且会决定到底先用什么索引，后用什么索引。

匹配左边的列
在联合索引中，如果想要用索引，条件中必须要从左到右连续的索引键，否则无法命中，因为B+树是按照索引定义进行创建的，那么用的时候也要按顺序来。

列前缀匹配
因为B+树是按照顺序排列组成的树，所以如果由如下sql
```sql
SELECT * FROM person_info WHERE name LIKE 'As%';
```
这样还是可以命中部分索引的。

匹配值范围
很好理解，B+树是按顺序构建的，所以范围是可以命中。比如
```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

另外多列的时候只有最左列会走索引。



精确匹配某一列并范围匹配另外一列
如果左边的列是精确查找，则右边的列可以进行范围查找，比如
```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```
name精确B+树索引，birthday走区间索引搜索，phone_number只能在前面得到的结果上进行扫描操作。

用于排序
`ORDER BY`子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤
`ORDER BY`的子句后边的列的顺序也必须按照索引列的顺序给出
规定使用联合索引的各个排序列的排序顺序必须是一致的，也就是不能混合desc、asc



回表的消耗
二级索引的内容是顺序排列，所以会在连续的数据页上，所以是顺序io。
从二级索引拿到聚簇索引后，通过聚簇索引去找记录，这个时候是随机io。随机io会比较慢。
所以当回表占大部分消耗的时候，就可以考虑不用二级索引，直接全表扫描。
所以，为了更快，查询的时候尽量不写*，尽量把索引覆盖了。


如何挑选索引
1. 只为用于搜索、排序、分组的列创建索引
2. 考虑列的基数，如果重复太多，就不适合建立索引。考虑为基数大的列做索引
3. 索引列的类型尽量小，越小越快
4. 可以建立索引字符串值得前缀索引
5. 让索引列在条件中单独出现，不要额外添加计算

## mysql的系统数据库
-   `mysql`
    
    这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。
    
-   `information_schema`
    
    这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引吧啦吧啦。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。
    
-   `performance_schema`
    
    这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。
    
-   `sys`
    
    这个数据库主要是通过视图的形式把`information_schema`和`performance_schema`结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。
	