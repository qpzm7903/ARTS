# maven 的依赖范围理解
[[[maven#依赖范围]]

增加一个实验。
比如一个简单的maven工程，里面有两个moudle，然后A中引入各种依赖，B依赖A，然后B依赖A的时候切换范围，从compile到provide，到runtime，到system等。然后通过mvn dependency:tree观察依赖结果。

三个pom分别如下

parent.pom
```xml
<?xml version="1.0" encoding="UTF-8"?>  
<project xmlns="http://maven.apache.org/POM/4.0.0"  
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">  
    <modelVersion>4.0.0</modelVersion>  
  
    <groupId>org.example</groupId>  
    <artifactId>untitled</artifactId>  
    <packaging>pom</packaging>  
    <version>1.0-SNAPSHOT</version>  
    <modules>        <module>A</module>  
        <module>B</module>  
    </modules>  
    <properties>        <maven.compiler.source>8</maven.compiler.source>  
        <maven.compiler.target>8</maven.compiler.target>  
    </properties>  
</project>
```

A.pom
```xml

<?xml version="1.0" encoding="UTF-8"?>  
<project xmlns="http://maven.apache.org/POM/4.0.0"  
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">  
    <parent>        <artifactId>untitled</artifactId>  
        <groupId>org.example</groupId>  
        <version>1.0-SNAPSHOT</version>  
    </parent>    <modelVersion>4.0.0</modelVersion>  
  
    <artifactId>A</artifactId>  
  
    <properties>        <maven.compiler.source>8</maven.compiler.source>  
        <maven.compiler.target>8</maven.compiler.target>  
    </properties>    <dependencies>        <dependency>            <groupId>org.junit.jupiter</groupId>  
            <artifactId>junit-jupiter-api</artifactId>  
            <version>5.8.2</version>  
            <scope>test</scope>  
        </dependency>  
        <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->  
        <dependency>  
            <groupId>mysql</groupId>  
            <artifactId>mysql-connector-java</artifactId>  
            <version>8.0.30</version>  
            <scope>runtime</scope>  
        </dependency>  
        <dependency>            <groupId>javax.servlet</groupId>  
            <artifactId>servlet-api</artifactId>  
            <version>2.5</version>  
            <scope>provided</scope>  
        </dependency>        <dependency>            <groupId>com.google.guava</groupId>  
            <artifactId>guava</artifactId>  
            <version>31.1-jre</version>  
            <scope>compile</scope>  
        </dependency>    </dependencies>  
</project>

```

B.pom
```xml
<?xml version="1.0" encoding="UTF-8"?>  
<project xmlns="http://maven.apache.org/POM/4.0.0"  
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">  
    <parent>        <artifactId>untitled</artifactId>  
        <groupId>org.example</groupId>  
        <version>1.0-SNAPSHOT</version>  
    </parent>    <modelVersion>4.0.0</modelVersion>  
  
    <artifactId>B</artifactId>  
  
    <properties>        <maven.compiler.source>8</maven.compiler.source>  
        <maven.compiler.target>8</maven.compiler.target>  
    </properties>  
    <dependencies>        <dependency>            <groupId>org.example</groupId>  
            <artifactId>A</artifactId>  
            <version>1.0-SNAPSHOT</version>  
            <scope>compile</scope>  
        </dependency>  
    </dependencies></project>
```


通过mvn dependency:tree可以知道，B在引入A时，不同的scope，就会影响依赖传递，具体如何传递，就看那个表格好了。
默认的compile会保持原有的，


# spring 自动配置原理


# spring 运行时监控 actuator用法