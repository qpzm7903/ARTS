#jstack

官网 https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html

基本用法
```
jstack [ option ] pid
jstack [ option ] executable core
jstack [ option ] [server-id@]remote-hostname-or-IP
```

options
```log
Usage:
    jstack [-l][-e] <pid>
        (to connect to running process)

Options:
    -l  long listing. Prints additional information about locks
    -e  extended listing. Prints additional information about threads
    -? -h --help -help to print this help message
```





## 死锁检测
```java
public class DeathLockTest {  
    private static Lock lock1 = new ReentrantLock();  
    private static Lock lock2 = new ReentrantLock();  
  
    public static void deathLock() {  
        Thread t1 = new Thread() {  
            @Override  
            public void run() {  
                try {  
                    lock1.lock();  
                    System.out.println(Thread.currentThread().getName() + " get the lock1");  
                    Thread.sleep(1000);  
                    lock2.lock();  
                    System.out.println(Thread.currentThread().getName() + " get the lock2");  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
        };  
        Thread t2 = new Thread() {  
            @Override  
            public void run() {  
                try {  
                    lock2.lock();  
                    System.out.println(Thread.currentThread().getName() + " get the lock2");  
                    Thread.sleep(1000);  
                    lock1.lock();  
                    System.out.println(Thread.currentThread().getName() + " get the lock1");  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
        };  
        //设置线程名字，方便分析堆栈信息  
        t1.setName("mythread-jay");  
        t2.setName("mythread-tianluo");  
        t1.start();  
        t2.start();  
    }  
    public static void main(String[] args) {  
        deathLock();  
    }  
}
```

jstack能检测到死锁

```log
PS C:\Users\qpzm7903> jstack 36468
2022-10-12 22:25:49
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.301-b09 mixed mode):

"DestroyJavaVM" #21 prio=5 os_prio=0 tid=0x0000023229b92800 nid=0x3f60 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"mythread-tianluo" #20 prio=5 os_prio=0 tid=0x000002325057d000 nid=0x4500 waiting on condition [0x000000ec5f0fe000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x0000000715de1db8> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)
        at java.util.concurrent.locks.LockSupport.park(Unknown Source)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(Unknown Source)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(Unknown Source)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Unknown Source)
        at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(Unknown Source)
        at java.util.concurrent.locks.ReentrantLock.lock(Unknown Source)
        at DeathLockTest$2.run(DeathLockTest.java:35)

"mythread-jay" #19 prio=5 os_prio=0 tid=0x000002325057c000 nid=0x8624 waiting on condition [0x000000ec5efff000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x0000000715de1de8> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)
        at java.util.concurrent.locks.LockSupport.park(Unknown Source)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(Unknown Source)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(Unknown Source)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Unknown Source)
        at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(Unknown Source)
        at java.util.concurrent.locks.ReentrantLock.lock(Unknown Source)
        at DeathLockTest$1.run(DeathLockTest.java:21)

"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x0000023250426000 nid=0x5cb0 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE

"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x0000023250425000 nid=0x5754 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x0000023250406000 nid=0x8c20 in Object.wait() [0x000000ec5deff000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x0000000715d08ee0> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(Unknown Source)
        - locked <0x0000000715d08ee0> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(Unknown Source)
        at java.lang.ref.Finalizer$FinalizerThread.run(Unknown Source)

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x000002324def8800 nid=0x8820 in Object.wait() [0x000000ec5ddfe000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x0000000715d06c00> (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Unknown Source)
        at java.lang.ref.Reference.tryHandlePending(Unknown Source)
        - locked <0x0000000715d06c00> (a java.lang.ref.Reference$Lock)
        at java.lang.ref.Reference$ReferenceHandler.run(Unknown Source)

```



## 高cpu占用检测

```java
public class HighCpuTest {  
    private static ExecutorService executorService = Executors.newFixedThreadPool(5);  
  
    public static void main(String[] args) {  
  
        Task task1 = new Task();  
        Task task2 = new Task();  
        executorService.execute(task1);  
        executorService.execute(task2);  
    }  
  
    public static Object lock = new Object();  
  
    static class Task implements Runnable{  
  
        public void run() {  
            synchronized (lock){  
                long sum = 0L;  
                while (true){  
                    sum += 1;  
                }  
            }  
        }  
    }  
}
```


```shell
jps

2275 HighCpuTest
2341 Jps

top -Hp 2275
top - 22:43:46 up  7:43,  0 users,  load average: 0.69, 0.22, 0.08
Threads:  19 total,   1 running,  18 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.0 sy,  4.2 ni, 95.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  25582.1 total,  25159.2 free,    190.6 used,    232.3 buff/cache
MiB Swap:   7168.0 total,   7168.0 free,      0.0 used.  25071.9 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
 2293 qpzm7903  25   5 9622816  41744  25724 R  99.9   0.2   1:06.40 pool-1-thread-1                 2275 qpzm7903  25   5 9622816  41744  25724 S   0.0   0.2   0:00.00 java
 2276 qpzm7903  25   5 9622816  41744  25724 S   0.0   0.2   0:00.01 java

pid = 2293

转成16进制

printf '0x%x\n' 2293
8f5

jstack 

"pool-1-thread-1" #20 prio=5 os_prio=0 cpu=139608.34ms elapsed=139.61s tid=0x00007f159c305800 nid=0x8f5 runnable  [0x00007f156962d000]
   java.lang.Thread.State: RUNNABLE
        at HighCpuTest$Task.run(HighCpuTest.java:28)
        - locked <0x000000068935add0> (a java.lang.Object)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@11.0.11/ThreadPoolExecutor.java:1128)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@11.0.11/ThreadPoolExecutor.java:628)
        at java.lang.Thread.run(java.base@11.0.11/Thread.java:829)

"pool-1-thread-2" #21 prio=5 os_prio=0 cpu=2.20ms elapsed=139.61s tid=0x00007f159c307000 nid=0x8f6 waiting for monitor entry  [0x00007f156952c000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at HighCpuTest$Task.run(HighCpuTest.java:26)
        - waiting to lock <0x000000068935add0> (a java.lang.Object)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@11.0.11/ThreadPoolExecutor.java:1128)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@11.0.11/ThreadPoolExecutor.java:628)
        at java.lang.Thread.run(java.base@11.0.11/Thread.java:829)

找到nid=0x8f5的线程，就是他消耗了大量的内存。

```