# 字节序 
有大端法 小端法两种。

首先：假设有32位无符号[[202202041944|16进制]]整数`0x12345678`。和十进制数一样，左边是高位，右边是低位。
内存空间16位。则每个内存地址可以存一个[[202202041944|16进制]]数，需要4个内存地址将此整数存入。存入的时候有两种方式。

| 0X0001 | 0X0002 | 0X0003 | 0X0004 |
| ------ | ------ | ------ | ------ |
| 0X12   | 0X34   | 0x56   | 0X78   |  
| 0X78   | 0X56   | 0X34   | 0X12   |  

第一种是大端法，将数值的高位至低位按序放入内存中。
第二种是小短法，将数值的低位至高位按序放入内存中。




使用python理解一下

```python
from ctypes import create_string_buffer  
from struct import Struct  
import numpy as np  
  
a = 0x12345678  
print('a: ', hex(a))  
for name, fmt in zip(['LittleEndian: ', 'BigEndian:    ', 'Network:      '],  
 [Struct('<1i'), Struct('>1i'), Struct('!1i')]):  
    buffer = create_string_buffer(fmt.size)  
    fmt.pack_into(buffer, 0, a)  
    data = np.frombuffer(buffer, dtype=np.uint8)  
    print(name, list(map(lambda x: hex(x), data)))
>>>
a:  0x12345678
LittleEndian:  ['0x78', '0x56', '0x34', '0x12']
BigEndian:     ['0x12', '0x34', '0x56', '0x78']
Network:       ['0x12', '0x34', '0x56', '0x78']
```