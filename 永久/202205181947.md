#vue
# vue


# vue-clie

## 使用 vue-cli初始化vue项目

```shell
# 安装
npm install -g @vue-cli

# create a project
vue create my-project
#or 
vue ui
```

# vue 配置文件
[官方指导](https://cli.vuejs.org/zh/config/)



# vue vscode 插件

- vetur
	- 支持.vue文件语法高亮
- ### [Vue VSCode Snippets](https://link.segmentfault.com/?enc=dc1CEca0GjLwol%2B3uxBwwQ%3D%3D.kplsZ8Yke1oZTfpGTduyLlZnqay5JOhQrY%2BKfetx6OHrrNSrNDNAF1JeLl9rvrNd27a%2F2r8f4%2FDX1NVzBo1th6QDjuuzKytGo1Xhgawkli4%3D)
	- 语法高亮、代码片段
		- 查看插件的配置

![[Pasted image 20220717105458.png]]


- ### [Auto Rename Tag](https://link.segmentfault.com/?enc=FA2ySmaS8Tjc3izT02AeeQ%3D%3D.FLF17SlLlLQkPHhrD1GKFWFviFUd6i7k8RwxL%2FdRiDTWlcom5kUGX85kYXWp%2BeKSbsPb282DfMVBFtgpo3tYI%2BVKZhQa%2BrbKTh259R0FEMk89VENemdRhs3YXPwtUocy)
	- 自动添加结束标记



# vue项目结构粗浅理解

写vue组件，组件和组件之间就像搭积木一样搭建起来，最后将顶层的组件暴露出去，通过在main.js里面

```js
import Vue from 'vue'

import App from './App.vue'

  

Vue.config.productionTip = false

  

new Vue({

  render: h => h(App),

}).$mount('#app')
```

在这里App就是顶层组件，然后将这个组件挂载到`#app`上。
而index.html里面实际只有有点点东西。
例如
```html
<!DOCTYPE html>

<html lang="">

  <head>

    <title>helloVue</title>

  </head>

  <body>

    <div id="app">

    </div>

    <!-- built files will be auto injected -->

  </body>

</html>
```



而每个组件都类似于如下结构
```vue
<template>

    <div>

      <div class="todo-footer">

        <label>

          <input type="checkbox"/>

        </label>

        <span>

          <span>已完成0</span> / 全部2

        </span>

        <button class="btn btn-danger">清除已完成任务</button>

      </div>

    </div>

</template>

  
<script>

    export default {

        name:"TodoFooter"

    }

</script>

  

<style  scoped>
  /*footer*/

  .todo-footer {

    height: 40px;

    line-height: 40px;

    padding-left: 6px;

    margin-top: 5px;

  }

</style>
```

包含 
- 模板
- 脚本
- 样式

分别对应传统前端的
- html
- javascript
- css




# vscode 配置

配置在 `.vscode/settings.json`

```json
{
    // vscode默认启用了根据文件类型自动设置tabsize的选项
    "editor.detectIndentation": false,
    // 重新设定tabsize
    "editor.tabSize": 4,
    // #每次保存的时候自动格式化
    "editor.formatOnSave": true,
    // #去掉代码结尾的分号
    "prettier.semi": false,
    // #使用带引号替代双引号
    "prettier.singleQuote": true,
    // #让函数(名)和后面的括号之间加个空格
    "javascript.format.insertSpaceBeforeFunctionParenthesis": true,
    // #这个按用户自身习惯选择
    "vetur.format.defaultFormatter.html": "js-beautify-html",
    // #让vue中的js按编辑器自带的ts格式进行格式化
    "vetur.format.defaultFormatter.js": "vscode-typescript",
    "vetur.format.defaultFormatterOptions": {
        "js-beautify-html": {
            "wrap_line_length": 120,
            "wrap_attributes": "auto"
            // #vue组件中html代码格式化样式
        }
    },
    // 格式化stylus, 需安装Manta's Stylus Supremacy插件
    "stylusSupremacy.insertColons": false, // 是否插入冒号
    "stylusSupremacy.insertSemicolons": false, // 是否插入分号
    "stylusSupremacy.insertBraces": false, // 是否插入大括号
    "stylusSupremacy.insertNewLineAroundImports": false, // import之后是否换行
    "stylusSupremacy.insertNewLineAroundBlocks": false,
    "explorer.confirmDelete": false, // 两个选择器中是否换行
    "editor.codeActionsOnSave": {
        "source.fixAll.eslint": true,
        "source.fixAll.stylelint": true
    },
    "workbench.iconTheme": "vs-seti",
    "files.autoSave": "off",
    "editor.suggestSelection": "first",
    "vsintellicode.modify.editor.suggestSelection": "automaticallyOverrodeDefaultValue",
    "diffEditor.ignoreTrimWhitespace": false,
    "window.zoomLevel": 0,
    "atomKeymap.promptV3Features": true,
    "editor.multiCursorModifier": "ctrlCmd",
    "editor.formatOnPaste": true,
    "guides.enabled": false,
    "eslint.format.enable": true,
    //autoFix默认开启，只需输入字符串数组即可
    "eslint.validate": [
        "javascript",
        "vue",
        "html"
    ],
    "[vue]": {
        "editor.defaultFormatter": "octref.vetur"
    },
    "editor.fontSize": 16,
    "vetur.validation.template": false,
    "[jsonc]": {
        "editor.defaultFormatter": "vscode.json-language-features"
    },
    // 关闭eslint 语法检测
    "eslint.enable": false
}
```



# vue的基础语法

vue在自己定义了一些列的html语法，比如循环，变量绑定，函数绑定等


## 组件之间传递数据  

### 直接依赖的组件
一把是上层组件传递给下层组件。


传递时通过 `:parameterName='value'`

然后被传递参数的组件需要再组件里面声明需要这个参数，就像是函数调用一样，需要声明参数，才能传递参数。




### 下层给上层传递消息

- 上层给下层传递一个函数 ， 或者说下层组件接受一个函数，用于发数据传递进去，上层组件是要提供这个函数就可以


### 那么任意之间组件怎么传递消息呢？
消息总线，这种不管是在前端，还是后端，从服务级别，到线程级别，进程级别，OS级别，都会用到。
总体来说，就是注册、侦听，触发、消费的过程。也就是观察者模式。

总线的要求
- 对所有组件可见
- 实现
	- `$on`
	- `$off`
	-  `$emit`


### 简单粗暴 window
直接在window对象上


### 在组件原型上
`vueComponent.prototype.__proto__ === Vue.prototype`

所以在Vue的原型上加
```
Vue.prototype.x = {...}  // 但这个对象不是vue组件，没有对应的方法
```


那么对象可以直接加到Vue原型上，那么如何让对象有`$on`等方法？
main.js
```js
new Vue({

    render: h => h(App),
    beforeCreate(){
	    Vue.prototype.$bus = this // 全局事件总线，加$ 是表示特殊，一般不用
    }

}).$mount('#app')
```


`$bus`  一般总线都叫这个名词

### 事件注册和销毁、触发

在某个组件里
```js
...
mouted (){
	this.总线名.$on('事件名',回调函数);
},

beforeDestroy(){
	this.总线名.$off('事件名')
}

...

this.总线名.$emit('事件名',参数)
```


## 消息订阅和发布
和总线有什么差异？原理是一样的，都是订阅-发布

三方库

- pubsub-js
	- publish-subscribe-javascript



### pubsub-js

安装
`npm i pubsubjs`

使用
注意这个回调函数，第一个参数默认是事件名

```js

import pubsub from 'pubsub-js'

pubsub.subscribe('name',function(enent_name, param...)) 
// 注意回调函数，可以直接传递this.method， 或者 (event_name, param)=>{
...
}

...
this.pubId = pubsub.publish('name',call_back_function(event_name, param...))

... 销毁
beforeDestroy(){
	pubsub.unsubscribe(this.pubId)
}


```

## 在模板里如何使用组件里的数据？
使用插值语法 {{ value }}

在标签里的值，例如
```html
<p1>{{ value }} </p1>
```

如果是标签属性

```html
<input type="checkbox" :checked="value" />
```

## 如何收集input的值？


### 通过双向绑定 或者 通过事件触发
- v-model进行双向的绑定，值变化的时候，使用到这个值的地方也会变化
- 键盘事件绑定，事件发生的时候会触发一个方法的回调，在回调里进行处理


例如
```html
<template>

  <div class="todo-header">

    <input type="text" placeholder="请输入你的任务名称，按回车键确认" v-model="title" @keyup.enter="addTodo" />

  </div>

</template>

  

<script>

export default {

  name: 'TotoFooter',

  data () {

    return {

      title: ""

    }

  },

  methods: {

    addTodo (event) {

      console.log(event.target.value)

    }

  }

}
```

# vue api


# vue 对象结构
```mermaid
classDiagram
	class VM
	
	class VueComponent
	
	class VueComponentInstance

```


# 常用发送http请求方式
#web-http
#vue-http

1. xhr 原始，底层， js内置
2. jQuery $.get, $.post 封装好的，但核心是操作dom的，80%的代码是操作dom
3. axios 封装好的，promise支持的，代码少
4. fetch 原生支持 js内置， promise风格，返回会包装两层promise，兼容性差，ie不支持

所以用axios比较合适


## axios 推荐使用
`npm i axios`

```js
import axios from 'axios'
axios.get('xxxx'). then( (response)=> {} ,(error)=>{}) 
```


## vue-resource  
vue 1.0 提供的http插件库，已经交给其他团队维护
[vue-resource](https://github.com/pagekit/vue-resource)

安装
````
npm install vue-resource
````
使用
```js
{
  // GET /someUrl
  this.$http.get('/someUrl').then(response => {

    // get body data
    this.someData = response.body;

  }, response => {
    // error callback
  });
}
```


main.js
```msin.js
...
// import plugin
import vueResource from 'vue-resource'
...

// use Plugin
Vue.user(vueResource)
...
// then all vm instance will hava $http variable

```

但是更推荐axios

# 跨域处理
[[202207210642|跨域处理]]


## vue代理服务器
https://cli.vuejs.org/zh/config/#devserver-proxy

配置代理的时候怎么配置把cookie、header都传递？



# vue的动画和过度支持
https://cn.vuejs.org/v2/guide/transitions.html

还可以和第三方的动画样式集成
比如  `animate`

https://animate.style/



# vue插槽
就是类似于模板模式？占位符？反正就是能做到开闭原则。

## 默认插槽
```js
<slot>default value<slot/>
```

## 具名插槽


```js

# definition
<slog name="xxx"></slog>

# using
<... slot="xxx">xxxxx</...>

or  vue 2.6~
<template v-slot:name>

</template>
```


## 作用域插槽
数据，结构，行为

那么就是，数据在哪里，这个数据用什么结构展示，有什么行为？

如下场景
App.vue
```App.vue
<template>
	<div>
		<Component>
			<template scope='aData'>
				... structure and behavior
			</template>
		</Component>
	</div>
</template>
```

Component.vue
```js
<template>
	<div>

		<slot scope='aData'></slot>
	</div>
</template>

<script>

....data(){
	return {
		aData:{...}
	}
}
</script>
```


把结构的定义放在使用方，但是数据在被使用的组件里，就用作用域插槽。


在scope属性里还可以用解构赋值，方便进行多个参数传递。



## 插槽组合使用
具名、默认、作用域是可以组合起来用的。



# vuex
#vue-vuex

用来做什么？
在Vue中做集中式状态管理的一个Vue插件，可以用于多个组件之间共享状态的集中式管理，是一种组件间通信的方式，可以在任意组件之间通信。

使用

main.js
```js
Vue.use(vuex)
```

和消息总线、事件的方式有什么差别？
总线、事件都是通过回调的方式进行数据的操作的，有一方提供回调函数，一方进行事件回调。
但是一些共享数据用总线的话可能比较重，尤其是很多组件都共用一些共享数据的时候。


那么什么数据适合做集中式管理呢？
就是很多组件都要用的，常见的可能是用户信息、租户信息

具体使用参考官网
https://vuex.vuejs.org/zh/

## 版本
vue2 -> vuex 3
vue3 -> vuex 4

所以安装的是默认是最新的，注意要指定版本


```shell
# 安装vue3
npm i vuex@3
```


## 交互图
可以经过action，也可以直接访问mutations，一般可以在action里面增加一些逻辑，比如判断，ajax调用等。如果没有的话，直接访问mutations也可以。


```mermaid 
sequenceDiagram
	component ->> action : dispacth(actionNamae, param)
	action ->> mutations: commit(commitName, param)
	action ->> context: dispactch(anotherActionName, param)
	mutations ->> store : read or write
	component ->> mutations : commit(commitName ,param)
	
```
要注意的是，vue devtools只观察了mutations的事件，actions的事件没有侦听，所以不要直接在actions里直接操作数据，避免开发的时候观察不到。

## vuex里的computed属性  （类似）
在store创建的时候，传入getters，
例如

```js
const getters = {
	bigSum(state){
		return state.sum * 10 /19 
	}
}
const store = new Vuex.Store({ 
	actions, 
	mutations, 
	state , 
	getters
	}
)
```


## 简化取值

vuex初始化后，取值的时候是
```
let value = this.$store.store.name
// or
let value = this.$store.getters.name
```

会重复的写 `this.$store.store`

vuex的一些帮助函数, 帮助生成一些函数，简化取值。

结合 ES6的解构赋值，会更加简便

```js
import {mapState} from 'vuex'

...
computed(){
	...mapState(functionName:'var_name_in_store')
}

```

mapState 返回的是函数

实际等价于

```js
...
computed(){
	functionName(){
		return this.$store.store.var_name_in_store
	}
}
```


更简便的写法（vuex真香）

```js

...mapState(['function_name'])
```
这种情况是function_name 和  var_name_in_store 相同的情况


## 其他mapper
和mapState类似，有 mapGetters、mapActions、mapMutations

那么 mapActions , mapMutations 映射出来的咋传参？

生成的代码类似于

```js

functionName(value){
	this.$store.dispatch('methodName',value)
}
```

如果是在事件里，不指定传参的时候，默认是event，所以在调用函数的地方传值即可。

```js
<template>
	<button click="functionName(value)"/>
</template>
```

或者事件绑定的是组件自定义的函数，在自定义的函数里调用vuex生成的函数，并传入想要的参数，这样template里就可以简单点。



## vuex 模块化
很显然，如果多个组件的数据都挤在一起，没有进行结构化管理，分门别类，那么后面肯定不好维护，没有做到分而治之，没有做到open close原则。

那么vuex提供了什么功能来解决这个问题呢？

https://vuex.vuejs.org/zh/guide/modules.html

# vue插件

# js里的uuid库 - nanoid
迷你的uuid实现，简单

```shell
npm i nanoid
```


最简单实用

```js
import {nanoid} from 'nanoid'
var id = nanoid()
```



## vc对象
vue component 对象

其中的
- data
- computed
- pros
	- 一般不修改prop传入的数据
- method
等都不能重名，所以注意啦！


## 自定义事件

### 绑定
方式1
1. 在要绑定的组件上用 `v-on:自定义事件名="事件发生时调用的函数"`
	1. 或者 `@自定义事件名="事件发生时调用的函数"`
	2. 绑定原生事件 `@事件名.native="回调函数"`
2. 在对应的组件里面触发 `this.$emit(自定义事件名)`


方式2，在组件挂载的时候加载
```js
<template>
<div>
	<ComponentA ref="componentA"/>
</div>
</template>
<script>
...
mounted(){
	this.$refs.componentA.$on("自定义事件名",this.事件发生时调用的函数)
}
</script>
```

ps
如果在`this.$refs.componentA.$on("自定义事件名",function(param...){})`
这种写法里直接绑定回调函数，那么里面的this实际是回调发生时所处的vue实例。

但是箭头函数可以
```js
	this.$refs.componentA.$on("自定义事件名",()=>{
	})
```

所以关键是寻找this对象怎么找，上下文的问题。
那么  function (xxx) {}  和  (xxx)=> {} 有什么区别？

### 解绑
绑定在谁身上，就在谁身上解绑，直接操作vc实例去删除对应的就可以了
```js

this.$off("自定义事件名")
# 或者
this.$off(["自定义事件名1","事件名2"...])
# 或者 解绑所有
this.$off()
# 销毁组件，也可以解绑事件
this.$destroy()
```

## vue实例的生命周期
![[生命周期.png]]

### 销毁
销毁会销毁对应的侦听事件，但是dom还是在
并且会销毁子组件

# 浏览器本地缓存
浏览器本地提供的api，可以操作localStorage、sessionStorage等，

- localStorage会一直保留

如下例子
```html
 window.localStorage.setItem(key,value)
 window.sessionStorage.setItem(key,value)
```



sessionStorage
- 浏览器会话
- 浏览器关闭，会话就结束