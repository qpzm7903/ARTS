# 反射

## 反射作用

运行期间改变程序的行为

反射的缺点？

性能不够好---原因是

可能有安全问题

内部暴露---比如私有方法也能反射执行



## Class

java虚拟机为每一种类型都创建了对应的Class实例，实例中包含引用类型、基础类型。

Class是反射的入口。Class包含了它的成员以及类型信息，并提供了创建对应类型实例的方法。



### 获取Class

没有对应的构造器，怎么获取Class？



#### `Object.getClass()`

如果有实例对象，直接`.getClass`方法就可以调用

#### `.class`

如果没有实例对象，但是有这个类型，那么类型名`.class`也可以获取对应的Class对象。

#### `Class.forName`静态方法

都没有的情况下，可以用这个方法。传入想要获取类的全限定名，也就是包含完整包名的名称。

这个方法无法获取基础数据类型。

那么数组类型呢？数组类型的语法是只有一个左括号，接着是类型的编码，然后到数据类型。

基础类型的数组不包含数据类型，引用类型的包含。

编码形式如下

| Element Type       |      | Encoding      |
| ------------------ | ---- | ------------- |
| boolean            |      | Z             |
| byte               |      | B             |
| char               |      | C             |
| class or interface |      | L*classname*; |
| double             |      | D             |
| float              |      | F             |
| int                |      | I             |
| long               |      | J             |
| short              |      | S             |

可以同`getName`方法来看看。

```java
System.out.println(String[].class.getName());  // [Ljava.lang.String;
System.out.println(byte[].class.getName()); // [B
System.out.println(int[].class.getName());// [I
System.out.println(long[].class.getName());// [J
System.out.println(double[].class.getName());// [D
System.out.println(float[].class.getName());// [F
System.out.println(boolean[].class.getName());// [Z
System.out.println(char[].class.getName());// [C
System.out.println(short[].class.getName());// [S
```

#### TYPE字段

void类型和基础类型的包装类型提供了方便的获取Class对象的字段，比如

```java
System.out.println(Void.TYPE.getName()); // void
System.out.println(Integer.TYPE.getName()); // int
```



#### 返回Class的一些方法