单元测试的目的

1、为了保护代码，UT写好后，如果对应代码修改了，逻辑不一致了，那么UT就会错误，这样就可以进行重构

2、TDD，测试驱动开发



测试的聚焦点

分层测试，被测对象直接依赖的对象，一般就进行mock



UT的大致结构

given

then

assert



测试的原则

FIRST

fast：快速

independent：独立

repeatable：可重复

self-validation：自我确认，也就是断言

timely：及时反馈（TDD）



Java、Junit和Mockito

最开始写Java代码的时候，写了一个类，就直接在这个类本身写main方法进行测试，输出结果，肉眼观察得到结果。



进阶一点，使用Junit框架，每个case就是一个加了@Test的方法，然后再使用断言，加上一点Before、After、Setup等Junit框架能力，还有异常处理等。



上面两个测试，再测试简单类，也就是不依赖其他类的时候都比较好测，或者说依赖的类可以直接new出来的时候，间接依赖也很好new的时候，就很方便。



但是当依赖、间接依赖都不方便构造、或者没法构造（比如要连数据库、网络请求等），就可以使用一些手段。

比如，如果依赖的都是接口，那么就自己实现接口，注入进去。

如果依赖的具体类，那么用一些代理类等手段处理。都可以自己简单的模拟依赖对象，但是这样写ut会有很多重复的东西。



这个是时候，Mockito测试框架就出现了。



@InjectMocks



@Mock



两个注解就可以解决依赖的问题，



when().thenReturn()就可以解决依赖方法的问题



veritfy().doxxx()就可以解决调用是否发生问题



when().thenAnwser()就可以解决直接return不够灵活，以及可以定制化方法的问题



有了这些方法，TDD可以很好的进行了，UT也可以写的比较爽。