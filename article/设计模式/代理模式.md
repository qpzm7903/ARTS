[TOC]

最终目的：i提高代码的可读性、可扩展性、复用性、维护性

# 一、设计原则

SOLID、KISS、YAGNI、DRY、LOD 

## 单一职责 single responsibility priciple

怎么判断一个类、一个方法的职责是否单一？

- 类中的代码行数、函数或者属性过多；

- 类依赖的其他类过多，或者依赖类的其他类过多；

- 私有方法过多；比较难给类起一个合适的名字；

- 类中大量的方法都是集中操作类中的某几个属性。
- 

## 开闭原则

对扩展开放，对修改关闭。

也就是说提倡扩展代码，而不是去修改代码。

所以写代码的时候就要考虑扩展性。

另外，这个原则也要看粒度，是针对于粗粒度还是细粒度。粗粒度的情况下，增加、修改任何一行代码都可以认为是修改。

而细粒度情况下，不影响代码原有的运行，那么就可以认为是扩展。

所以有个初衷：不改变原有代码的正常运行，不破坏原有的单元测试，就可以认为是合格的修改，可以认为是扩展。

这个原则实践起来就是：识别代码中可变和不可变部分，封装可变部分，隔离变化，提供接口，基于接口编程。接口时灵活的，可替换的。



## 里氏替换

子类可以替换父类，并且保证原来程序的逻辑行为不变

和多态有什么区别。

多态时OOP的特性，而里氏替换是以一种设计原则，多态不保证子类替换或程序逻辑不变。



## 接口隔离

依赖接口，而不是实现





## 依赖反转

类似的概念还有控制反转，依赖注入。

控制反转的意思是：程序员把对程序流程的控制交给框架。所以控制是对流程的控制，反转时从程序员交给了框架。

模板方法就是一种常用的控制反转实现。



依赖注入，spring容器的依赖注入就是典型的例子。不要自己去new实例，而是通过构造方法、bean注入等方式从外部注入。



依赖反转的意思呢就是，高层模块不要依赖底层模块，两者应该通过抽象来互相依赖。

也就是依赖接口，而不是实现。



# 二、设计模式

## 2.1、创建型

### 2.1.1、单例模式

1. 构造函数是private的，不对外暴露
2. 对象创建的时候要线程安全
3. 是否考虑延迟加载
4. 获取单例性能是否高
### 饿汉式
启动的时候就将类初始化，不支持延迟加载
```java

public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static final IdGenerator instance = new IdGenerator();
  private IdGenerator() {}
  public static IdGenerator getInstance() {
    return instance;
  }
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

### 懒汉模式
使用的时候才加载，并且用锁锁住，有性能问题。只能应付偶尔使用的场景
```java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static final IdGenerator instance;
  private IdGenerator() {}
  public synchronized static IdGenerator getInstance() {
      if (instance == null){
          instance = new IdGenerator();
          return instance;
      }
    return instance;
  }
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

### 双重检测

```java
public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private static final IdGenerator instance;
  private IdGenerator() {}
  public  static IdGenerator getInstance() {
      if (instance == null){
        synchronized(IdGenerator.class){
        if (instance == null){
          instance = new IdGenerator();
        }
        return instance;
        }
      }
    return instance;
  }
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

### 静态内部类
交给 JVM 处理
```java

public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private IdGenerator() {}

  private static class SingletonHolder{
    private static final IdGenerator instance = new IdGenerator();
  }
  
  public static IdGenerator getInstance() {
    return SingletonHolder.instance;
  }
 
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

### 枚举
```java

public enum IdGenerator {
  INSTANCE;
  private AtomicLong id = new AtomicLong(0);
 
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

### 缺点

违反OOP原则，基于接口，而不是实现。

依赖关系不清晰，用到的时候才知道

扩展不友好

测试性不好

不支持有参构造器



### 进程内单例 和 线程内单例
进程内单例也自然是线程内单例。

一个进程可以有多个线程，线程单例就是进程中的每个线程都可以有自己的单例对象，不同线程之间不同。ThreadLocal就是java提供的线程单例。



### 2.1.2、工厂模式

简单工厂、工厂方法、抽象工厂

什么场景用new，什么场景用工厂？用工厂有什么好处

工厂的目的：将类的创建和使用解耦开

#### 简单工厂

通过if、else判断然后创建

或者map、表驱动的形式

扩展的时候就需要增加一个if或者map里面的一行

#### 工厂方法

将if去掉，通过多态的方式解决

扩展的时候需要增加对应的类

简单工厂和工厂方法可以结合起来用。

简单工厂的map形式提供多态的工厂类，工厂类再创建对应的类。



比较

工厂方法将逻辑分散开来

简单工厂的逻辑聚合在一块。

当逻辑简单的时候，考虑用简单工厂，复杂的时候考虑用工厂方法。



#### 抽象工厂





### 2.1.3、建造者模式

建造者模式可以避免构造器参数冗长，并且把参数之间的校验逻辑放到builder里面，以及可以控制对象的状态，比如不给对象添加set方法，只能通过builder，那么状态就可以确定。

### 2.1.4、原型模式

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。



## 结构型



## 行为型



### 代理模式

代理模式是什么？

它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能，达到提供额外的功能的目的。

和装饰器模式不同，装饰器的目的是增强类原有的功能。



#### 静态代理

### 基于接口

定义一个接口

```java
public interface IUserController {
    UserVo login(String userName,String password);
    UserVo register(String userName, String password);
}
```

一个实现类

```java
public class IUserControllerImpl implements IUserController {
    @Override
    public UserVo login(String userName, String password) {
        System.out.println(userName + "login");
        return new UserVo(userName, password);
    }

    @Override
    public UserVo register(String userName, String password) {
        System.out.println(userName + "register");
        return new UserVo(userName, password);
    }
}
```



然后实现一个代理类

```java
public class IUserControllerProxy implements IUserController {

    private IUserController userController;

    public IUserControllerProxy(IUserController userController) {
        this.userController = userController;
    }


    @Override

    public UserVo login(String userName, String password) {
        // do something before login
        UserVo userVo = userController.login(userName, password);
        // do something after login
        return userVo;
    }

    @Override
    public UserVo register(String userName, String password) {
        // do something before register
        UserVo userVo = userController.register(userName, password);
        // do something after register
        return userVo;
    }
}
```



然后在替换，将实际的调用委托给了代理。



```java
public class Main {
    public static void main(String[] args) {
        IUserController userController = new IUserControllerProxy(new IUserControllerImpl());
    }
}
```



基于接口实现代理的前提是必须有接口，且有源码，才能达到替换的目的，而且业务和其他代理的功能高度耦合在一起，达不到职责单一的原则。

### 基于继承

对于外部扩展，可以使用基于继承的方式，例如。

```java
public class IUserControllerProxyByExtends extends IUserControllerImpl {
    @Override
    public UserVo login(String userName, String password) {
        // do something before login
        UserVo user = super.login(userName, password);
        // do something after login
        return user;
    }

    @Override
    public UserVo register(String userName, String password) {
        // do something before register
        UserVo user = super.register(userName, password);
        // do something after register
        return user;
    }
}
```

调用的时候

```java
public class Main {
    public static void main(String[] args) {
        IUserController userController = new IUserControllerProxyByExtends();
    }
}
```



### 总结

**静态代理的缺点**

需要手动写，如果类很多的时候，会很麻烦，增加维护成本，并且代码是很多重复的。

组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。
继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。



#### 动态代理

### java动态代理

java动态代理基于反射机制。动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。

```java
public class IUserControllerDynamicProxy {
    public Object createProxy(Object proxyObject){
        Class<?>[] interfaces = proxyObject.getClass().getInterfaces();
        DynamicProxyHandler handler = new DynamicProxyHandler(proxyObject);
        return Proxy.newProxyInstance(proxyObject.getClass().getClassLoader(), interfaces, handler);
    }

    private static class DynamicProxyHandler implements InvocationHandler {

        private Object proxyObject;

        public DynamicProxyHandler(Object proxyObject) {
            this.proxyObject = proxyObject;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            long startTimeStamp = System.currentTimeMillis();
            Object result = method.invoke(proxyObject, args);
            long endTimeStamp = System.currentTimeMillis();
            String apiName = proxyObject.getClass().getName() + ":" + method.getName();
            System.out.println("invoke api:" + apiName + "  cost " + (endTimeStamp - startTimeStamp) + "ms");
            return result;
        }
    }

    public static void main(String[] args) {
        IUserControllerDynamicProxy proxy = new IUserControllerDynamicProxy();
        IUserController userController = (IUserController) proxy.createProxy(new IUserControllerImpl());
        userController.login("test", "test");
        userController.register("test", "test");
    }
}
```

spring AOP的底层实现就是基于动态代理，spring为这些代理的类创建代理对象，然后在JVM中替换原始对象。

### API

动态代理类是运行时创建的实现了一些列接口的类

代理接口是代理类实现的接口

代理实例是冬天代理类的一个实例

### 创建一个代理类

使用[java.lang.reflect.Proxy](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html])的`getProxyClass`方法。







### cglib代理

[cglib](https://github.com/cglib/cglib),可以动态代理没有实现接口的类，底层是使用字节码处理框架**ASM**。

#### 加载依赖

如果已经加载了spring core，就不用，因为里面已经依赖了。

```xml
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version>
</dependency>

```

#### 例子

```java
public class UserControllerProxy  implements MethodInterceptor {

    private Object target;

    public UserControllerProxy(Object target) {
        this.target = target;
    }

    public Object getProxyInstance() {
        Enhancer enhancer = new Enhancer();

        enhancer.setSuperclass(target.getClass());

        enhancer.setCallback(this);

        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        long startTimeStamp = System.currentTimeMillis();
        Object result = method.invoke(target, args);
        long endTimeStamp = System.currentTimeMillis();
        String apiName = target.getClass().getName() + ":" + method.getName();
        System.out.println("invoke api:" + apiName + "  cost " + (endTimeStamp - startTimeStamp) + "ms");
        return result;
    }

    public static void main(String[] args) {
        UserController userController = (UserController) new UserControllerProxy(new UserController()).getProxyInstance();
        userController.login("test", "test");
        userController.register("test", "test");
    }
}
```

### 总结

java中,动态代理的实现基于**字节码生成技术**(代码里就是newProxyInstance片段),可以在jvm运行时动态生成和加载字节码,类似的技术还有asm,cglib,javassist,平时编译java用的javac命令就是字节码生成技术的"老祖宗"
 java中用到字节码生成技术的还有JSP编译器.AOP框架,反射等等





#### 代理模式的应用场景

### 非功能性开发

监控、统计、鉴权、限流、事务、幂等、日志等

### 在RPC，缓存中的应用

RPC框架可以认为是一种远程代理模式

缓存功能，通过代理增加，在代理中判断一些参数来决定是用缓存的内容还是走原始路径。



#### 参考

https://time.geekbang.org/column/article/201823

[java代理模式](https://segmentfault.com/a/1190000011291179#:~:text=%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%A9%E7%94%A8%E4%BA%86JDK,%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E7%9A%84class%E6%96%87%E4%BB%B6)

https://github.com/cglib/cglib

https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html#intro