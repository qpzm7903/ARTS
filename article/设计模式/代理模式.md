[TOC]



# 代理模式

代理模式是什么？

它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能，达到提供额外的功能的目的。

和装饰器模式不同，装饰器的目的是增强类原有的功能。



## 静态代理

### 基于接口

定义一个接口

```java
public interface IUserController {
    UserVo login(String userName,String password);
    UserVo register(String userName, String password);
}
```

一个实现类

```java
public class IUserControllerImpl implements IUserController {
    @Override
    public UserVo login(String userName, String password) {
        System.out.println(userName + "login");
        return new UserVo(userName, password);
    }

    @Override
    public UserVo register(String userName, String password) {
        System.out.println(userName + "register");
        return new UserVo(userName, password);
    }
}
```



然后实现一个代理类

```java
public class IUserControllerProxy implements IUserController {

    private IUserController userController;

    public IUserControllerProxy(IUserController userController) {
        this.userController = userController;
    }


    @Override

    public UserVo login(String userName, String password) {
        // do something before login
        UserVo userVo = userController.login(userName, password);
        // do something after login
        return userVo;
    }

    @Override
    public UserVo register(String userName, String password) {
        // do something before register
        UserVo userVo = userController.register(userName, password);
        // do something after register
        return userVo;
    }
}
```



然后在替换，将实际的调用委托给了代理。



```java
public class Main {
    public static void main(String[] args) {
        IUserController userController = new IUserControllerProxy(new IUserControllerImpl());
    }
}
```



基于接口实现代理的前提是必须有接口，且有源码，才能达到替换的目的，而且业务和其他代理的功能高度耦合在一起，达不到职责单一的原则。

### 基于继承

对于外部扩展，可以使用基于继承的方式，例如。

```java
public class IUserControllerProxyByExtends extends IUserControllerImpl {
    @Override
    public UserVo login(String userName, String password) {
        // do something before login
        UserVo user = super.login(userName, password);
        // do something after login
        return user;
    }

    @Override
    public UserVo register(String userName, String password) {
        // do something before register
        UserVo user = super.register(userName, password);
        // do something after register
        return user;
    }
}
```

调用的时候

```java
public class Main {
    public static void main(String[] args) {
        IUserController userController = new IUserControllerProxyByExtends();
    }
}
```



### 总结

**静态代理的缺点**

需要手动写，如果类很多的时候，会很麻烦，增加维护成本，并且代码是很多重复的。

组合模式的优点在于更加灵活，对于接口的所有子类都可以代理，缺点在于不需要扩展的方法也需要进行代理。
继承模式的优点在于只需要针对需要扩展的方法进行代理，缺点在于只能针对单一父类进行代理。



## 动态代理

### java动态代理

java动态代理基于反射机制。动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。

```java
public class IUserControllerDynamicProxy {
    public Object createProxy(Object proxyObject){
        Class<?>[] interfaces = proxyObject.getClass().getInterfaces();
        DynamicProxyHandler handler = new DynamicProxyHandler(proxyObject);
        return Proxy.newProxyInstance(proxyObject.getClass().getClassLoader(), interfaces, handler);
    }

    private static class DynamicProxyHandler implements InvocationHandler {

        private Object proxyObject;

        public DynamicProxyHandler(Object proxyObject) {
            this.proxyObject = proxyObject;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            long startTimeStamp = System.currentTimeMillis();
            Object result = method.invoke(proxyObject, args);
            long endTimeStamp = System.currentTimeMillis();
            String apiName = proxyObject.getClass().getName() + ":" + method.getName();
            System.out.println("invoke api:" + apiName + "  cost " + (endTimeStamp - startTimeStamp) + "ms");
            return result;
        }
    }

    public static void main(String[] args) {
        IUserControllerDynamicProxy proxy = new IUserControllerDynamicProxy();
        IUserController userController = (IUserController) proxy.createProxy(new IUserControllerImpl());
        userController.login("test", "test");
        userController.register("test", "test");
    }
}
```

spring AOP的底层实现就是基于动态代理，spring为这些代理的类创建代理对象，然后在JVM中替换原始对象。



### cglib代理

[cglib](https://github.com/cglib/cglib),可以动态代理没有实现接口的类，底层是使用字节码处理框架**ASM**。

#### 加载依赖

如果已经加载了spring core，就不用，因为里面已经依赖了。

```xml
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version>
</dependency>

```

#### 例子

```java
public class UserControllerProxy  implements MethodInterceptor {

    private Object target;

    public UserControllerProxy(Object target) {
        this.target = target;
    }

    public Object getProxyInstance() {
        Enhancer enhancer = new Enhancer();

        enhancer.setSuperclass(target.getClass());

        enhancer.setCallback(this);

        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        long startTimeStamp = System.currentTimeMillis();
        Object result = method.invoke(target, args);
        long endTimeStamp = System.currentTimeMillis();
        String apiName = target.getClass().getName() + ":" + method.getName();
        System.out.println("invoke api:" + apiName + "  cost " + (endTimeStamp - startTimeStamp) + "ms");
        return result;
    }

    public static void main(String[] args) {
        UserController userController = (UserController) new UserControllerProxy(new UserController()).getProxyInstance();
        userController.login("test", "test");
        userController.register("test", "test");
    }
}
```

### 总结

java中,动态代理的实现基于**字节码生成技术**(代码里就是newProxyInstance片段),可以在jvm运行时动态生成和加载字节码,类似的技术还有asm,cglib,javassist,平时编译java用的javac命令就是字节码生成技术的"老祖宗"
 java中用到字节码生成技术的还有JSP编译器.AOP框架,反射等等





## 代理模式的应用场景

### 非功能性开发

监控、统计、鉴权、限流、事务、幂等、日志等

### 在RPC，缓存中的应用

RPC框架可以认为是一种远程代理模式

缓存功能，通过代理增加，在代理中判断一些参数来决定是用缓存的内容还是走原始路径。



## 参考

https://time.geekbang.org/column/article/201823

[java代理模式](https://segmentfault.com/a/1190000011291179#:~:text=%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%A9%E7%94%A8%E4%BA%86JDK,%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E7%9A%84class%E6%96%87%E4%BB%B6)

