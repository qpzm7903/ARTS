## 16 章 UML类图

关联线

```uml
visibility name : type multiplicity = default {property-string}
```

导航性箭头

- 源
- 目标
- 多重性
- 角色名

比如，使用关联关系指明Student具有对Course实例的多个引用

![image-20211027071708186](D:\workspace\github\ARTS\读书笔记\UML和模式应用.assets\image-20211027071708186.png)

关键字 一般用 双尖括号表示，也有用大括号表示，比如抽象

依赖线

>  准则：在类图中，使用依赖线描述对象之间的全局变量、参数变量、局部变量和静态方法（对其他类的静态方法加以调用）的依赖。

组合和聚合

组合优于聚合

> 聚合（aggregation）是UML中一种模糊的关联，其不精确地暗示了整体-部分关系（和许多普通关联一样）

组合是一种很强的整体-部分聚合的关系，部分不能脱离整体存在。部分的生命周期和整体一致。

关联类

可以把关联本身作为类，使用属性，操作，等其他特性对其简模。

比如

![image-20211027073133099](D:\workspace\github\ARTS\读书笔记\UML和模式应用.assets\image-20211027073133099.png)




依赖：是一种耦合关系
组合优于聚合：聚合是一种不清晰的关系，还不如使用关联
关联：
关联类：允许将关联本身作为类。类比ER图，就是中间表的意思。

## 17 GRASP：基于职责设计对象
职责驱动设计：
职责：
- 对象的认知
- 对象的行为



GRASP：定义了9个OO基本原则
- 信息专家
- 创建者
- 高内聚
- 低耦合
- 控制器
- 多态
- 间接性
- 纯虚构
- 防止变异
GOF：23个设计模式，3种类型


## 18 使用GRASP的对象设计示例

CQS原则：命令-查询分离原则
如下例子,将命令和查询的分离

```java
public void roll(){
	this.value = randValue();
}

public int getFaceValue(){
	return this.value;
}

```

但是我们经常这样使用
```java
public int rool(){
	this.value = randValue();
	return this.value;
}

```



中级主题

UML活动图以及建模


## 30 用例关联
在细化阶段才开始逐渐演化。前期应该只有简单的用例文本。

用例的关系：
- 包含
	- 对复用的用例进行抽取，则使用到复用的用例，用包含关系。被包含的用例是单独的用例。
	- 表示法：在文本里，简单地使用下划线表示
	- 使用准则：当多个或多个用例存在重复，想要避免冗余，就可以提取子用例，使用包含关系。

- 扩展关系
	- 在用例已经稳定、无法进行大修改地情况下，使用扩展关系对用例进行扩展。
		- 在用例中增加扩展点，

- 泛化关系
	- 复杂，不建议使用


## 31 领域模型的精化

也就是模型中的关系，比如泛化、关联、关联类，组合、聚合等。

## 33 架构分析
架构分析会考虑更多的非功能性，但是功能性需求提供了相关的语境。同时考虑功能性需求里的变化点和进化点。
变化点：现有系统或需求的变化之处
进化点：现在需求不存在的，未来可能发生，是推断的。

架构分析中有因素、优先级、对业务的影响度等角度。一般使用表格展示。同时对于多种方案的选择中，要给出选择方案的原因。同时未选方案要加入到技术备忘录中。将相关信息也补充进去，比如未选的原因。
架构分析在贯穿整个迭代，当代码稳定的时候，架构才可能稳定，这时候架构分析的结果才可以被新人学习。

架构分析的角度；
- 可靠性、容错性
- 可适应性、配置性


架构因素：
质量场景，定义可观测、可度量的质量需求。比如每秒并发支持多少，每秒事务支持多少。

描述架构的因素
|因素|度量和质量场景|可变性|该因素对涉众、架构、以及其他因素的影响|对成功的优先级|困难或者风险|

架构行因素和制品：用例是来源，输出的东西应该反哺到用例中。

基本原则：低耦合、高内聚、防止变异。只不过在更大粒度的使用，不是小对象之间。而是应用程序、进程、子系统之间的。

## 34 逻辑架构的精化
